% !TeX encoding = UTF-8
\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage{tempora}
\usepackage{indentfirst}

\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} % AMS
\usepackage{icomma}
\usepackage{mathrsfs}

\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{xcolor} % for setting colors
\lstset{
	basicstyle=\scriptsize\ttfamily,
	commentstyle=\ttfamily\color{gray},
	numbers=left,
	numberstyle=\ttfamily\color{gray}\footnotesize,
	stepnumber=1,
	numbersep=5pt,
	backgroundcolor=\color{gray!10},
	rulecolor=\color{black!30},
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	frame=single,
	tabsize=2,
	captionpos=b,
	breaklines=true,
	breakatwhitespace=false,
	title=\lstname,
	escapeinside={},
	keywordstyle={},
	morekeywords={},
    extendedchars=false,
    inputencoding=utf8
}

\usepackage[left=3cm,right=1.5cm,top=2cm,bottom=2cm]{geometry}
\author{Игорь Комолых, Сергей Лущик}
\title{Лабораторные работы по курсу "Параллельное~и~распределённое~программирование"}
\date{\today}

\begin{document}
	\begin{titlepage}
		\maketitle
	\end{titlepage}
	
	\section{Умножение матриц}\label{sec:lab1}

	Эта лабораторная работа заключалась в сравнении последовательной и параллельной реализации алгоритмов умножения матриц,
	а так же в сравнении времени работы программы при разных способах обхода массива.

	В результате выполнения работы были получены:
	\begin{itemize}
		\item описанный класс Matrix
		\item bash и sbatch файлы запуска программы на персональных компьютерах и кластере САФУ
		\item python-скрипт для построения графиков из полученных данных.
 	\end{itemize}

	Результатом выполнения программы является строка, в которой через запятую указаны количество используемых потоков, размерность квадратной матрицы, время работы. При запуске bash или sbatch сценариев, происходит формирование CSV-файла, по данным которого в дальнейшем можно строить графики ускорения, эффективности и времени работы (см. Рис.~\ref{fig:beforeChange} и~\ref{fig:afterChange}). Программы собирались и запускались на вычислительном кластере САФУ.

	\begin{figure}[h]
		\centering
		\includegraphics[scale=.5]{result}
		\caption{графики до смены порядка обхода матриц.}
		\label{fig:beforeChange} 
	\end{figure}

	\begin{figure}[h]
		\centering
		\includegraphics[scale=.5]{result_trs}
		\caption{графики после смены порядка обхода матриц.}
		\label{fig:afterChange} 
	\end{figure}

	По рис.~\ref{fig:beforeChange} и~\ref{fig:afterChange} видно, что после изменения порядка обхода матрицы с привычного ``строки-столбцы'' на ``столбцы-строки'' (см. Листинг~\ref{lst:matrixLookup}) время работы программы может сокращаться в 2 и более раза, в некоторых случаях удавалось достичь ускорения в 4-5 раз.

	Данный пример демонстрирует особенности устройства кэша процессора и оперативной памяти. При обращении к какой-либо ячейке памяти, в кэш вместе с ней загружаются и несколько соседних ячеек. При обращении в порядке ``строки-столбцы'' два элемента, над которыми производятся операции в смежных итерациях алгоритма, в памяти будут находиться на расстоянии, равном размеру строки матрицы. Если же обходить массивы в порядке ``столбцы-строки'', смежные итерации будут оперировать элементами одной строки матрицы, элементы которой располагаются в памяти друг за другом.
	
	\begin{lstlisting}[language=C++, caption={Два способа обхода матрицы}, label={lst:matrixLookup}, texcl=true]
	//
	// строки-столбцы
	//
				#pragma omp parallel for shared(result, first, second)
				for (size_t i = 0; i < result.rows(); ++i) 
					for (size_t j = 0; j < result.cols(); ++j) {
						result(i, j) = 0;
						for (size_t k = 0; k < result.rows(); ++k) 
							result(i, j) += first(i, k) * second(k, j);
					}
					
		//
		// столбцы-строки
		//

				#pragma omp parallel for shared(result, first, second)
				for (size_t j = 0; j < result.cols(); ++j) 
					for (size_t i = 0; i < result.rows(); ++i) {
						result(i, j) = 0;
						for (size_t k = 0; k < result.rows(); ++k) 
							result(i, j) += first(i, k) * second(j, k);
					}

	\end{lstlisting}
	\section{Задача Дирихле для уравнения Пуассона}\label{sec:lab2}

	С использованием класса матриц, полученного в ходе выполнения первой лабораторной были реализованы последовательный и параллельный алгоритмы решения задачи Дирихле для уравнения Пуассона, написаны python-скрипты для построения графиков поверхностей по полученным данным.
	Результат тестового запуска алгоритма для уравнения $f(x,y) = 4$ с краевыми условиями $g(x,y) =(x - 0.5)^2 + (x - 0.5)^2$ представлен на рис.~\ref{fig:surfPlot}.
	\begin{figure}[h]
		\centering
		\includegraphics[scale=0.5]{surface_plot}
		\caption{График решения задачи Дирихле для уравнения Пуассона.}
		\label{fig:surfPlot} 
	\end{figure}

	Для того чтобы гарантировать получение точно таких же решений, как и в непараллельном алгоритме Гаусса-Зейделя, параллельный алгоритм был построен по волновой схеме. Для вычисления начения текущего элемента $U_{i j}$ алгоритм Гаусса-Зейделя использует два ранее вычеслинных элемента $U_{i-1 j}$, Вначале, таким условиям удовлетворяет только элемент $U_{1 1}$, однако, после его подсчета становится доступна следующая диагональ $U_{2 1}$-$U_{1 2}$. Получаем,	что выполнение одной итерации можно разбить на последовательность шагов, на каждом из которых вычисляются узлы, расположенные на одной из диагоналей исходной сетки. 
	
	Реали

\end{document}